-- ============================================
-- 채팅방 시스템 스키마
-- 매칭 성사 후에만 채팅 가능하도록 구현
-- Supabase SQL Editor에서 실행하세요
-- ============================================

-- ============================================
-- 1. Chat Rooms 테이블 (채팅방)
-- ============================================

CREATE TABLE IF NOT EXISTS public.chat_rooms (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
  
  -- 참여자 (두 명의 사용자)
  user1_id UUID REFERENCES public.users(id) ON DELETE CASCADE NOT NULL,
  user2_id UUID REFERENCES public.users(id) ON DELETE CASCADE NOT NULL,
  
  -- 매칭 요청 참조 (어떤 매칭에서 생성되었는지)
  matching_request_id BIGINT REFERENCES public.matching_requests(id) ON DELETE SET NULL,
  
  -- 마지막 메시지 정보 (목록 표시용)
  last_message TEXT,
  last_message_at TIMESTAMP WITH TIME ZONE,
  last_message_sender_id UUID REFERENCES public.users(id) ON DELETE SET NULL,
  
  -- 채팅방 상태
  is_active BOOLEAN DEFAULT true,
  
  -- 중복 방지: 같은 두 사용자 간에는 하나의 채팅방만 존재
  UNIQUE(user1_id, user2_id)
);

-- Chat Rooms 인덱스
CREATE INDEX IF NOT EXISTS idx_chat_rooms_user1 ON public.chat_rooms(user1_id);
CREATE INDEX IF NOT EXISTS idx_chat_rooms_user2 ON public.chat_rooms(user2_id);
CREATE INDEX IF NOT EXISTS idx_chat_rooms_last_message_at ON public.chat_rooms(last_message_at DESC);
CREATE INDEX IF NOT EXISTS idx_chat_rooms_active ON public.chat_rooms(is_active);

-- Chat Rooms RLS 설정
ALTER TABLE public.chat_rooms ENABLE ROW LEVEL SECURITY;

-- 사용자는 자신이 참여한 채팅방만 볼 수 있음
DROP POLICY IF EXISTS "Users can view own chat rooms" ON public.chat_rooms;
CREATE POLICY "Users can view own chat rooms"
  ON public.chat_rooms FOR SELECT
  USING (auth.uid() = user1_id OR auth.uid() = user2_id);

-- 시스템에서 채팅방 생성 (트리거 또는 서비스에서)
DROP POLICY IF EXISTS "System can create chat rooms" ON public.chat_rooms;
CREATE POLICY "System can create chat rooms"
  ON public.chat_rooms FOR INSERT
  WITH CHECK (true);

-- 참여자는 채팅방 업데이트 가능 (마지막 메시지 등)
DROP POLICY IF EXISTS "Participants can update chat rooms" ON public.chat_rooms;
CREATE POLICY "Participants can update chat rooms"
  ON public.chat_rooms FOR UPDATE
  USING (auth.uid() = user1_id OR auth.uid() = user2_id);

-- ============================================
-- 2. Messages 테이블 수정 (room_id 추가)
-- ============================================

-- room_id 컬럼 추가 (기존 테이블에)
ALTER TABLE public.messages 
ADD COLUMN IF NOT EXISTS room_id BIGINT REFERENCES public.chat_rooms(id) ON DELETE CASCADE;

-- room_id 인덱스 추가
CREATE INDEX IF NOT EXISTS idx_messages_room_id ON public.messages(room_id);

-- ============================================
-- 3. Messages RLS 정책 업데이트
-- 채팅방 참여자만 메시지 조회/전송 가능
-- ============================================

-- 기존 정책 삭제
DROP POLICY IF EXISTS "Users can view own messages" ON public.messages;
DROP POLICY IF EXISTS "Users can send messages" ON public.messages;
DROP POLICY IF EXISTS "Users can update own messages" ON public.messages;

-- 새 정책: 채팅방 참여자만 메시지 조회 가능
CREATE POLICY "Chat room participants can view messages"
  ON public.messages FOR SELECT
  USING (
    EXISTS (
      SELECT 1 FROM public.chat_rooms cr
      WHERE cr.id = room_id
      AND (cr.user1_id = auth.uid() OR cr.user2_id = auth.uid())
    )
    OR room_id IS NULL -- 기존 메시지 호환성
  );

-- 새 정책: 채팅방 참여자만 메시지 전송 가능
CREATE POLICY "Chat room participants can send messages"
  ON public.messages FOR INSERT
  WITH CHECK (
    EXISTS (
      SELECT 1 FROM public.chat_rooms cr
      WHERE cr.id = room_id
      AND cr.is_active = true
      AND (cr.user1_id = auth.uid() OR cr.user2_id = auth.uid())
    )
    OR room_id IS NULL -- 기존 메시지 호환성
  );

-- 새 정책: 메시지 업데이트 (읽음 처리 등)
CREATE POLICY "Recipients can update message read status"
  ON public.messages FOR UPDATE
  USING (recipient_id = auth.uid());

-- ============================================
-- 4. 매칭 수락 시 자동 채팅방 생성 트리거
-- ============================================

-- 채팅방 생성 함수
CREATE OR REPLACE FUNCTION public.create_chat_room_on_match_accepted()
RETURNS TRIGGER AS $$
DECLARE
  new_room_id BIGINT;
  smaller_id UUID;
  larger_id UUID;
BEGIN
  -- 매칭이 수락된 경우에만 실행
  IF NEW.status = 'accepted' AND (OLD.status IS NULL OR OLD.status = 'pending') THEN
    
    -- 일관성을 위해 ID를 정렬 (중복 방지)
    IF NEW.from_user_id < NEW.to_user_id THEN
      smaller_id := NEW.from_user_id;
      larger_id := NEW.to_user_id;
    ELSE
      smaller_id := NEW.to_user_id;
      larger_id := NEW.from_user_id;
    END IF;
    
    -- 이미 채팅방이 있는지 확인
    SELECT id INTO new_room_id
    FROM public.chat_rooms
    WHERE (user1_id = smaller_id AND user2_id = larger_id);
    
    -- 채팅방이 없으면 새로 생성
    IF new_room_id IS NULL THEN
      INSERT INTO public.chat_rooms (user1_id, user2_id, matching_request_id)
      VALUES (smaller_id, larger_id, NEW.id)
      RETURNING id INTO new_room_id;
      
      RAISE NOTICE '새 채팅방 생성됨: room_id=%, user1=%, user2=%', new_room_id, smaller_id, larger_id;
    ELSE
      -- 기존 채팅방이 있으면 활성화
      UPDATE public.chat_rooms
      SET is_active = true, matching_request_id = NEW.id
      WHERE id = new_room_id;
      
      RAISE NOTICE '기존 채팅방 재활성화: room_id=%', new_room_id;
    END IF;
  END IF;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 트리거 생성 (매칭 상태 변경 시)
DROP TRIGGER IF EXISTS on_match_accepted_create_chat_room ON public.matching_requests;
CREATE TRIGGER on_match_accepted_create_chat_room
  AFTER UPDATE ON public.matching_requests
  FOR EACH ROW
  EXECUTE FUNCTION public.create_chat_room_on_match_accepted();

-- INSERT 시에도 트리거 (바로 accepted로 생성되는 경우 대비)
DROP TRIGGER IF EXISTS on_match_insert_create_chat_room ON public.matching_requests;
CREATE TRIGGER on_match_insert_create_chat_room
  AFTER INSERT ON public.matching_requests
  FOR EACH ROW
  WHEN (NEW.status = 'accepted')
  EXECUTE FUNCTION public.create_chat_room_on_match_accepted();

-- ============================================
-- 5. 메시지 전송 시 채팅방 last_message 업데이트 트리거
-- ============================================

CREATE OR REPLACE FUNCTION public.update_chat_room_last_message()
RETURNS TRIGGER AS $$
BEGIN
  -- 채팅방의 마지막 메시지 정보 업데이트
  IF NEW.room_id IS NOT NULL THEN
    UPDATE public.chat_rooms
    SET 
      last_message = NEW.content,
      last_message_at = NEW.created_at,
      last_message_sender_id = NEW.sender_id
    WHERE id = NEW.room_id;
  END IF;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

DROP TRIGGER IF EXISTS on_message_update_chat_room ON public.messages;
CREATE TRIGGER on_message_update_chat_room
  AFTER INSERT ON public.messages
  FOR EACH ROW
  EXECUTE FUNCTION public.update_chat_room_last_message();

-- ============================================
-- 6. 채팅방 조회 헬퍼 함수
-- ============================================

-- 특정 사용자의 채팅방 목록 조회
CREATE OR REPLACE FUNCTION public.get_user_chat_rooms(p_user_id UUID)
RETURNS TABLE (
  room_id BIGINT,
  partner_id UUID,
  partner_name TEXT,
  partner_avatar TEXT,
  partner_gender TEXT,
  last_message TEXT,
  last_message_at TIMESTAMP WITH TIME ZONE,
  is_last_message_mine BOOLEAN,
  unread_count BIGINT,
  created_at TIMESTAMP WITH TIME ZONE
) AS $$
BEGIN
  RETURN QUERY
  SELECT 
    cr.id as room_id,
    CASE WHEN cr.user1_id = p_user_id THEN cr.user2_id ELSE cr.user1_id END as partner_id,
    u.name as partner_name,
    u.profile_image as partner_avatar,
    u.gender as partner_gender,
    cr.last_message,
    cr.last_message_at,
    cr.last_message_sender_id = p_user_id as is_last_message_mine,
    COALESCE((
      SELECT COUNT(*) 
      FROM public.messages m 
      WHERE m.room_id = cr.id 
      AND m.recipient_id = p_user_id 
      AND m.is_read = false
    ), 0) as unread_count,
    cr.created_at
  FROM public.chat_rooms cr
  JOIN public.users u ON u.id = CASE 
    WHEN cr.user1_id = p_user_id THEN cr.user2_id 
    ELSE cr.user1_id 
  END
  WHERE (cr.user1_id = p_user_id OR cr.user2_id = p_user_id)
  AND cr.is_active = true
  ORDER BY COALESCE(cr.last_message_at, cr.created_at) DESC;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 두 사용자 간의 채팅방 조회 (없으면 NULL)
CREATE OR REPLACE FUNCTION public.get_chat_room_between_users(p_user1_id UUID, p_user2_id UUID)
RETURNS BIGINT AS $$
DECLARE
  room_id BIGINT;
  smaller_id UUID;
  larger_id UUID;
BEGIN
  IF p_user1_id < p_user2_id THEN
    smaller_id := p_user1_id;
    larger_id := p_user2_id;
  ELSE
    smaller_id := p_user2_id;
    larger_id := p_user1_id;
  END IF;
  
  SELECT id INTO room_id
  FROM public.chat_rooms
  WHERE user1_id = smaller_id AND user2_id = larger_id AND is_active = true;
  
  RETURN room_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ============================================
-- 7. Realtime 활성화 (Supabase 대시보드에서도 확인 필요)
-- ============================================

-- chat_rooms 테이블 Realtime 활성화
ALTER PUBLICATION supabase_realtime ADD TABLE public.chat_rooms;

-- ============================================
-- 완료!
-- ============================================
-- 
-- 이제 매칭이 수락되면:
-- 1. matching_requests 상태가 'accepted'로 변경
-- 2. 자동으로 chat_rooms에 채팅방 생성
-- 3. 해당 채팅방에서만 메시지 주고받기 가능
-- 
-- 사용 예시:
-- SELECT * FROM get_user_chat_rooms('사용자-UUID');
-- SELECT get_chat_room_between_users('사용자1-UUID', '사용자2-UUID');
-- 

