-- ============================================
-- Attract ë°ì´í„°ë² ì´ìŠ¤ í†µí•© ìŠ¤í‚¤ë§ˆ
-- ë°ì´í„°ë² ì´ìŠ¤ ì¬ìƒì„±ìš© ì™„ì „í•œ ìŠ¤í‚¤ë§ˆ
-- ============================================

-- ============================================
-- 1. Storage Buckets ì„¤ì •
-- ============================================

-- í”„ë¡œí•„ ì´ë¯¸ì§€ìš© ë²„í‚· ìƒì„±
INSERT INTO storage.buckets (id, name, public)
VALUES ('profile-images', 'profile-images', true)
ON CONFLICT (id) DO NOTHING;

-- Storage ì •ì±… ì„¤ì •
CREATE POLICY IF NOT EXISTS "Public Access"
  ON storage.objects FOR SELECT
  USING (bucket_id = 'profile-images');

CREATE POLICY IF NOT EXISTS "Authenticated users can upload images"
  ON storage.objects FOR INSERT
  WITH CHECK (bucket_id = 'profile-images' AND auth.role() = 'authenticated');

CREATE POLICY IF NOT EXISTS "Users can update own images"
  ON storage.objects FOR UPDATE
  USING (bucket_id = 'profile-images' AND auth.uid() = owner);

CREATE POLICY IF NOT EXISTS "Users can delete own images"
  ON storage.objects FOR DELETE
  USING (bucket_id = 'profile-images' AND auth.uid() = owner);

-- ============================================
-- 2. Users í…Œì´ë¸”
-- ============================================

CREATE TABLE IF NOT EXISTS public.users (
  id UUID REFERENCES auth.users ON DELETE CASCADE NOT NULL PRIMARY KEY,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()),
  
  -- ê¸°ë³¸ ì •ë³´
  name TEXT,
  email TEXT,
  phone_number TEXT,
  avatar_url TEXT,
  profile_image TEXT,
  
  -- í”„ë¡œí•„ ì •ë³´
  age INTEGER,
  gender TEXT CHECK (gender IN ('male', 'female')),
  location TEXT,
  bio TEXT,
  school TEXT,
  job TEXT,
  
  -- ì„±ê²© ë° ì·¨í–¥
  mbti TEXT,
  height TEXT,
  body_type TEXT,
  style TEXT,
  religion TEXT,
  smoking TEXT,
  drinking TEXT,
  interests TEXT[],
  
  -- Firebase ì—°ë™
  firebase_uid TEXT UNIQUE,
  
  -- ì½”ì¸ ì‹œìŠ¤í…œ
  coins INTEGER DEFAULT 150
);

-- Users í…Œì´ë¸” ì¸ë±ìŠ¤
CREATE INDEX IF NOT EXISTS idx_users_firebase_uid ON public.users(firebase_uid);
CREATE INDEX IF NOT EXISTS idx_users_gender ON public.users(gender);

-- Users RLS ì„¤ì •
ALTER TABLE public.users ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Public profiles are viewable by everyone" ON public.users;
CREATE POLICY "Public profiles are viewable by everyone"
  ON public.users FOR SELECT
  USING (true);

DROP POLICY IF EXISTS "Users can insert their own profile" ON public.users;
CREATE POLICY "Users can insert their own profile"
  ON public.users FOR INSERT
  WITH CHECK (auth.uid() = id);

DROP POLICY IF EXISTS "Users can update own profile" ON public.users;
CREATE POLICY "Users can update own profile"
  ON public.users FOR UPDATE
  USING (auth.uid() = id);

-- ============================================
-- 3. Community Posts í…Œì´ë¸”
-- ============================================

CREATE TABLE IF NOT EXISTS public.community_posts (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()),
  
  -- ì‘ì„±ì ì •ë³´
  user_id UUID REFERENCES auth.users NOT NULL,
  author_name TEXT,
  avatar_url TEXT,
  
  -- ê²Œì‹œê¸€ ë‚´ìš©
  title TEXT,
  content TEXT,
  image_url TEXT,
  category TEXT,
  
  -- í†µê³„
  likes INTEGER DEFAULT 0,
  views INTEGER DEFAULT 0,
  comment_count INTEGER DEFAULT 0,
  
  -- ì‘ì„±ì í”„ë¡œí•„ ì •ë³´ (ìŠ¤ëƒ…ìƒ·)
  age INTEGER,
  location TEXT,
  job TEXT,
  gender TEXT,
  bio TEXT,
  school TEXT
);

-- Community Posts ì¸ë±ìŠ¤
CREATE INDEX IF NOT EXISTS idx_community_posts_user_id ON public.community_posts(user_id);
CREATE INDEX IF NOT EXISTS idx_community_posts_category ON public.community_posts(category);
CREATE INDEX IF NOT EXISTS idx_community_posts_created_at ON public.community_posts(created_at DESC);

-- Community Posts RLS ì„¤ì •
ALTER TABLE public.community_posts ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Public posts access" ON public.community_posts;
CREATE POLICY "Public posts access"
  ON public.community_posts FOR SELECT
  USING (true);

DROP POLICY IF EXISTS "Authenticated users can create posts" ON public.community_posts;
CREATE POLICY "Authenticated users can create posts"
  ON public.community_posts FOR INSERT
  WITH CHECK (auth.role() = 'authenticated');

DROP POLICY IF EXISTS "Users can update own posts" ON public.community_posts;
CREATE POLICY "Users can update own posts"
  ON public.community_posts FOR UPDATE
  USING (auth.uid() = user_id);

DROP POLICY IF EXISTS "Users can delete own posts" ON public.community_posts;
CREATE POLICY "Users can delete own posts"
  ON public.community_posts FOR DELETE
  USING (auth.uid() = user_id);

-- ============================================
-- 4. Post Likes í…Œì´ë¸”
-- ============================================

CREATE TABLE IF NOT EXISTS public.community_post_likes (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
  user_id UUID REFERENCES auth.users NOT NULL,
  post_id BIGINT REFERENCES public.community_posts(id) ON DELETE CASCADE NOT NULL,
  
  UNIQUE(user_id, post_id)
);

-- Post Likes ì¸ë±ìŠ¤
CREATE INDEX IF NOT EXISTS idx_post_likes_user_id ON public.community_post_likes(user_id);
CREATE INDEX IF NOT EXISTS idx_post_likes_post_id ON public.community_post_likes(post_id);

-- Post Likes RLS ì„¤ì •
ALTER TABLE public.community_post_likes ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Public likes access" ON public.community_post_likes;
CREATE POLICY "Public likes access"
  ON public.community_post_likes FOR SELECT
  USING (true);

DROP POLICY IF EXISTS "Authenticated users can like" ON public.community_post_likes;
CREATE POLICY "Authenticated users can like"
  ON public.community_post_likes FOR INSERT
  WITH CHECK (auth.role() = 'authenticated');

DROP POLICY IF EXISTS "Users can unlike" ON public.community_post_likes;
CREATE POLICY "Users can unlike"
  ON public.community_post_likes FOR DELETE
  USING (auth.uid() = user_id);

-- ============================================
-- 5. Post Comments í…Œì´ë¸”
-- ============================================

CREATE TABLE IF NOT EXISTS public.post_comments (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()),
  
  post_id BIGINT REFERENCES public.community_posts(id) ON DELETE CASCADE NOT NULL,
  user_id UUID REFERENCES auth.users NOT NULL,
  
  author_name TEXT,
  avatar_url TEXT,
  content TEXT,
  likes INTEGER DEFAULT 0
);

-- Post Comments ì¸ë±ìŠ¤
CREATE INDEX IF NOT EXISTS idx_post_comments_post_id ON public.post_comments(post_id);
CREATE INDEX IF NOT EXISTS idx_post_comments_user_id ON public.post_comments(user_id);

-- Post Comments RLS ì„¤ì •
ALTER TABLE public.post_comments ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Public comments access" ON public.post_comments;
CREATE POLICY "Public comments access"
  ON public.post_comments FOR SELECT
  USING (true);

DROP POLICY IF EXISTS "Authenticated users can comment" ON public.post_comments;
CREATE POLICY "Authenticated users can comment"
  ON public.post_comments FOR INSERT
  WITH CHECK (auth.role() = 'authenticated');

DROP POLICY IF EXISTS "Users can update own comments" ON public.post_comments;
CREATE POLICY "Users can update own comments"
  ON public.post_comments FOR UPDATE
  USING (auth.uid() = user_id);

DROP POLICY IF EXISTS "Users can delete own comments" ON public.post_comments;
CREATE POLICY "Users can delete own comments"
  ON public.post_comments FOR DELETE
  USING (auth.uid() = user_id);

-- ============================================
-- 6. Notifications í…Œì´ë¸”
-- ============================================

CREATE TABLE IF NOT EXISTS public.notifications (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
  
  -- ìˆ˜ì‹ ì
  user_id UUID REFERENCES auth.users NOT NULL,
  
  -- ë°œì‹ ì (ì„ íƒì )
  from_user_id UUID REFERENCES auth.users,
  from_user_name TEXT,
  from_user_avatar TEXT,
  
  -- ì•Œë¦¼ ë‚´ìš©
  type TEXT NOT NULL CHECK (type IN ('like', 'match', 'match_accepted', 'comment')),
  message TEXT NOT NULL,
  content TEXT,
  
  -- ê´€ë ¨ ë°ì´í„°
  post_id BIGINT REFERENCES public.community_posts(id) ON DELETE CASCADE,
  
  -- ìƒíƒœ
  is_read BOOLEAN DEFAULT false
);

-- Notifications ì¸ë±ìŠ¤
CREATE INDEX IF NOT EXISTS idx_notifications_user_id ON public.notifications(user_id);
CREATE INDEX IF NOT EXISTS idx_notifications_is_read ON public.notifications(is_read);
CREATE INDEX IF NOT EXISTS idx_notifications_created_at ON public.notifications(created_at DESC);

-- Notifications RLS ì„¤ì •
ALTER TABLE public.notifications ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Users can view own notifications" ON public.notifications;
CREATE POLICY "Users can view own notifications"
  ON public.notifications FOR SELECT
  USING (auth.uid() = user_id);

DROP POLICY IF EXISTS "Users can update own notifications" ON public.notifications;
CREATE POLICY "Users can update own notifications"
  ON public.notifications FOR UPDATE
  USING (auth.uid() = user_id);

DROP POLICY IF EXISTS "Users can delete own notifications" ON public.notifications;
CREATE POLICY "Users can delete own notifications"
  ON public.notifications FOR DELETE
  USING (auth.uid() = user_id);

DROP POLICY IF EXISTS "System can create notifications" ON public.notifications;
CREATE POLICY "System can create notifications"
  ON public.notifications FOR INSERT
  WITH CHECK (true);

-- ============================================
-- 7. Matching Requests í…Œì´ë¸”
-- ============================================

CREATE TABLE IF NOT EXISTS public.matching_requests (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()),
  
  -- ìš”ì²­ìì™€ ìˆ˜ì‹ ì
  from_user_id UUID REFERENCES auth.users NOT NULL,
  to_user_id UUID REFERENCES auth.users NOT NULL,
  
  -- ìƒíƒœ
  status TEXT DEFAULT 'pending' CHECK (status IN ('pending', 'accepted', 'rejected')),
  
  UNIQUE(from_user_id, to_user_id)
);

-- Matching Requests ì¸ë±ìŠ¤
CREATE INDEX IF NOT EXISTS idx_matching_requests_from_user ON public.matching_requests(from_user_id);
CREATE INDEX IF NOT EXISTS idx_matching_requests_to_user ON public.matching_requests(to_user_id);
CREATE INDEX IF NOT EXISTS idx_matching_requests_status ON public.matching_requests(status);

-- Matching Requests RLS ì„¤ì •
ALTER TABLE public.matching_requests ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Users can view related requests" ON public.matching_requests;
CREATE POLICY "Users can view related requests"
  ON public.matching_requests FOR SELECT
  USING (auth.uid() = from_user_id OR auth.uid() = to_user_id);

DROP POLICY IF EXISTS "Users can create requests" ON public.matching_requests;
CREATE POLICY "Users can create requests"
  ON public.matching_requests FOR INSERT
  WITH CHECK (auth.uid() = from_user_id);

DROP POLICY IF EXISTS "Users can update received requests" ON public.matching_requests;
CREATE POLICY "Users can update received requests"
  ON public.matching_requests FOR UPDATE
  USING (auth.uid() = to_user_id);

DROP POLICY IF EXISTS "Users can delete own requests" ON public.matching_requests;
CREATE POLICY "Users can delete own requests"
  ON public.matching_requests FOR DELETE
  USING (auth.uid() = from_user_id);

-- Matching Requests ìë™ì‚­ì œ ì •ì±… (24ì‹œê°„ í›„ pending ìš”ì²­ ì‚­ì œ)
CREATE OR REPLACE FUNCTION public.auto_delete_expired_matching_requests()
RETURNS void AS $$
BEGIN
  DELETE FROM public.matching_requests
  WHERE status = 'pending' 
    AND created_at < now() - INTERVAL '24 hours';
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ë§¤ì¼ ìì •ì— ìë™ ì‹¤í–‰ (í•„ìš”ì‹œ pg_cron í™•ì¥ í•„ìš”)
-- SELECT cron.schedule('delete-expired-matching-requests', '0 0 * * *', 'SELECT public.auto_delete_expired_matching_requests()');

-- ë˜ëŠ” ì•±ì—ì„œ ì£¼ê¸°ì ìœ¼ë¡œ í˜¸ì¶œí•˜ëŠ” ë°©ë²• ê¶Œì¥

-- ============================================
-- 8. Messages í…Œì´ë¸” (ì±„íŒ…)
-- ============================================

CREATE TABLE IF NOT EXISTS public.messages (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
  
  -- ë°œì‹ ìì™€ ìˆ˜ì‹ ì
  sender_id UUID REFERENCES auth.users NOT NULL,
  recipient_id UUID REFERENCES auth.users NOT NULL,
  
  -- ë©”ì‹œì§€ ë‚´ìš©
  content TEXT NOT NULL,
  
  -- ì½ìŒ ì—¬ë¶€
  is_read BOOLEAN DEFAULT false,
  read_at TIMESTAMP WITH TIME ZONE
);

-- Messages ì¸ë±ìŠ¤
CREATE INDEX IF NOT EXISTS idx_messages_sender_id ON public.messages(sender_id);
CREATE INDEX IF NOT EXISTS idx_messages_recipient_id ON public.messages(recipient_id);
CREATE INDEX IF NOT EXISTS idx_messages_created_at ON public.messages(created_at DESC);
CREATE INDEX IF NOT EXISTS idx_messages_conversation ON public.messages(sender_id, recipient_id);

-- Messages RLS ì„¤ì •
ALTER TABLE public.messages ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Users can view own messages" ON public.messages;
CREATE POLICY "Users can view own messages"
  ON public.messages FOR SELECT
  USING (auth.uid() = sender_id OR auth.uid() = recipient_id);

DROP POLICY IF EXISTS "Users can send messages" ON public.messages;
CREATE POLICY "Users can send messages"
  ON public.messages FOR INSERT
  WITH CHECK (auth.uid() = sender_id);

DROP POLICY IF EXISTS "Users can update own messages" ON public.messages;
CREATE POLICY "Users can update own messages"
  ON public.messages FOR UPDATE
  USING (auth.uid() = recipient_id);

-- ============================================
-- 9. Coin Packages í…Œì´ë¸”
-- ============================================

CREATE TABLE IF NOT EXISTS public.coin_packages (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
  
  name TEXT NOT NULL,
  coins INTEGER NOT NULL,
  bonus_coins INTEGER DEFAULT 0,
  price INTEGER NOT NULL,
  is_popular BOOLEAN DEFAULT false,
  display_order INTEGER DEFAULT 0
);

-- Coin Packages RLS ì„¤ì •
ALTER TABLE public.coin_packages ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Public can view packages" ON public.coin_packages;
CREATE POLICY "Public can view packages"
  ON public.coin_packages FOR SELECT
  USING (true);

-- ê¸°ë³¸ ì½”ì¸ íŒ¨í‚¤ì§€ ë°ì´í„°
INSERT INTO public.coin_packages (name, coins, bonus_coins, price, is_popular, display_order)
VALUES 
  ('ìŠ¤íƒ€í„°', 100, 0, 1100, false, 1),
  ('ë² ì´ì§', 300, 30, 3300, false, 2),
  ('í”„ë¦¬ë¯¸ì—„', 500, 100, 5500, true, 3),
  ('VIP', 1000, 300, 11000, false, 4)
ON CONFLICT DO NOTHING;

-- ============================================
-- 9. Coin Packages í…Œì´ë¸”
-- ============================================

-- ìƒˆ ìœ ì € ê°€ì… ì‹œ ìë™ìœ¼ë¡œ public.usersì— í–‰ ì¶”ê°€
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.users (id, name, avatar_url, email)
  VALUES (
    NEW.id,
    COALESCE(NEW.raw_user_meta_data->>'name', NEW.email),
    NEW.raw_user_meta_data->>'avatar_url',
    NEW.email
  );
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE PROCEDURE public.handle_new_user();

-- ê²Œì‹œê¸€ ì¢‹ì•„ìš” ì‹œ ì•Œë¦¼ ìƒì„±
CREATE OR REPLACE FUNCTION public.notify_post_like()
RETURNS TRIGGER AS $$
DECLARE
  post_author_id UUID;
  liker_name TEXT;
  liker_avatar TEXT;
BEGIN
  -- ê²Œì‹œê¸€ ì‘ì„±ì ID ê°€ì ¸ì˜¤ê¸°
  SELECT user_id INTO post_author_id
  FROM public.community_posts
  WHERE id = NEW.post_id;
  
  -- ìê¸° ìì‹ ì˜ ê²Œì‹œê¸€ì— ì¢‹ì•„ìš”í•œ ê²½ìš° ì•Œë¦¼ ìƒì„± ì•ˆ í•¨
  IF post_author_id = NEW.user_id THEN
    RETURN NEW;
  END IF;
  
  -- ì¢‹ì•„ìš” ëˆ„ë¥¸ ì‚¬ìš©ì ì •ë³´ ê°€ì ¸ì˜¤ê¸°
  SELECT name, avatar_url INTO liker_name, liker_avatar
  FROM public.users
  WHERE id = NEW.user_id;
  
  -- ì•Œë¦¼ ìƒì„±
  INSERT INTO public.notifications (
    user_id,
    from_user_id,
    from_user_name,
    from_user_avatar,
    type,
    message,
    post_id
  ) VALUES (
    post_author_id,
    NEW.user_id,
    liker_name,
    liker_avatar,
    'like',
    liker_name || 'ë‹˜ì´ íšŒì›ë‹˜ì˜ ê²Œì‹œê¸€ì„ ì¢‹ì•„í•©ë‹ˆë‹¤.',
    NEW.post_id
  );
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

DROP TRIGGER IF EXISTS on_post_like ON public.community_post_likes;
CREATE TRIGGER on_post_like
  AFTER INSERT ON public.community_post_likes
  FOR EACH ROW EXECUTE PROCEDURE public.notify_post_like();

-- ë§¤ì¹­ ìš”ì²­ ì‹œ ì•Œë¦¼ ìƒì„±
CREATE OR REPLACE FUNCTION public.notify_match_request()
RETURNS TRIGGER AS $$
DECLARE
  requester_name TEXT;
  requester_avatar TEXT;
BEGIN
  -- ìš”ì²­ì ì •ë³´ ê°€ì ¸ì˜¤ê¸°
  SELECT name, avatar_url INTO requester_name, requester_avatar
  FROM public.users
  WHERE id = NEW.from_user_id;
  
  -- ì•Œë¦¼ ìƒì„±
  INSERT INTO public.notifications (
    user_id,
    from_user_id,
    from_user_name,
    from_user_avatar,
    type,
    message
  ) VALUES (
    NEW.to_user_id,
    NEW.from_user_id,
    requester_name,
    requester_avatar,
    'match',
    requester_name || 'ë‹˜ì´ ë§¤ì¹­ì„ ìš”ì²­í–ˆìŠµë‹ˆë‹¤.'
  );
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

DROP TRIGGER IF EXISTS on_match_request ON public.matching_requests;
CREATE TRIGGER on_match_request
  AFTER INSERT ON public.matching_requests
  FOR EACH ROW EXECUTE PROCEDURE public.notify_match_request();

-- ë§¤ì¹­ ìˆ˜ë½ ì‹œ ì•Œë¦¼ ìƒì„±
CREATE OR REPLACE FUNCTION public.notify_match_accepted()
RETURNS TRIGGER AS $$
DECLARE
  accepter_name TEXT;
  accepter_avatar TEXT;
BEGIN
  -- ìƒíƒœê°€ acceptedë¡œ ë³€ê²½ëœ ê²½ìš°ì—ë§Œ
  IF NEW.status = 'accepted' AND OLD.status = 'pending' THEN
    -- ìˆ˜ë½í•œ ì‚¬ìš©ì ì •ë³´ ê°€ì ¸ì˜¤ê¸°
    SELECT name, avatar_url INTO accepter_name, accepter_avatar
    FROM public.users
    WHERE id = NEW.to_user_id;
    
    -- ìš”ì²­ìì—ê²Œ ì•Œë¦¼ ìƒì„±
    INSERT INTO public.notifications (
      user_id,
      from_user_id,
      from_user_name,
      from_user_avatar,
      type,
      message
    ) VALUES (
      NEW.from_user_id,
      NEW.to_user_id,
      accepter_name,
      accepter_avatar,
      'match_accepted',
      accepter_name || 'ë‹˜ì´ ë§¤ì¹­ì„ ìˆ˜ë½í–ˆìŠµë‹ˆë‹¤! ğŸ‰'
    );
  END IF;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

DROP TRIGGER IF EXISTS on_match_accepted ON public.matching_requests;
CREATE TRIGGER on_match_accepted
  AFTER UPDATE ON public.matching_requests
  FOR EACH ROW EXECUTE PROCEDURE public.notify_match_accepted();

-- ============================================
-- ì™„ë£Œ
-- ============================================
-- ì´ ìŠ¤í‚¤ë§ˆëŠ” Attract ì•±ì˜ ëª¨ë“  ê¸°ëŠ¥ì„ ì§€ì›í•©ë‹ˆë‹¤.
-- ì‹¤í–‰ ë°©ë²•: Supabase SQL Editorì—ì„œ ì „ì²´ ë‚´ìš©ì„ ë³µì‚¬í•˜ì—¬ ì‹¤í–‰
